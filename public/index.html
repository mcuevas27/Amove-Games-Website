<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDF Circuit Tracer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #0f0;
            font-family: monospace;
            pointer-events: none;
            z-index: 100;
        }
        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 4px;
            line-height: 1.6;
        }
        #stats span { color: #0ff; }
    </style>
    <!-- Import map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Amove Games...</div>
    <div id="stats" style="display:none">
        FPS: <span id="fps">0</span><br>
        Particles: <span id="particleCount">0</span><br>
        Lines: <span id="lineCount">0</span>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Configuration - Multiple SDFs
        const SDF_CONFIGS = [
            {
                name: 'x',
                binPath: 'data_x.bin',
                metaPath: 'data_x.json',
                position: new THREE.Vector3(0, 0, 0),
                scale: 0.8,
                rotation: null // No rotation
            }
        ];

        // Default preset
        const defaultParams = {
            // Spawning
            spawnRate: 200,        // particles per second
            inboundSpeed: 0.05,
            // Movement
            crawlSpeed: 0.018,
            turnChance: 37,        // percentage (0-100)
            crawlerLifeSec: 1,    // seconds
            // Trails
            trailFadeSec: 2.3,      // seconds
            trailColor: '#4f9ee8',
            multiColor: false,     // each tracer gets a unique color
            // Visual
            headSize: 0.03,
            showHeads: false,
            showTrails: true,
            // Bloom
            bloomStrength: 2.0,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            // Debug
            paused: false,
            autoRotate: true
        };

        // Active params (copy of defaults)
        const params = { ...defaultParams };

        // Presets
        const presets = {
            'Default': { ...defaultParams },
            'Dense Circuit': {
                spawnRate: 30, inboundSpeed: 0.08, crawlSpeed: 0.008,
                turnChance: 15, crawlerLifeSec: 8, trailFadeSec: 4,
                trailColor: '#00ffff', multiColor: true, headSize: 0.02, showHeads: true,
                showTrails: true, bloomStrength: 2.0, bloomRadius: 0.5, bloomThreshold: 0.1,
                paused: false, autoRotate: true
            },
            'Sparse Slow': {
                spawnRate: 3, inboundSpeed: 0.02, crawlSpeed: 0.005,
                turnChance: 2, crawlerLifeSec: 10, trailFadeSec: 6,
                trailColor: '#ff00ff', multiColor: false, headSize: 0.05, showHeads: true,
                showTrails: true, bloomStrength: 1.0, bloomRadius: 0.3, bloomThreshold: 0.2,
                paused: false, autoRotate: false
            },
            'Fast Chaos': {
                spawnRate: 20, inboundSpeed: 0.15, crawlSpeed: 0.03,
                turnChance: 25, crawlerLifeSec: 2, trailFadeSec: 1,
                trailColor: '#ffff00', multiColor: true, headSize: 0.04, showHeads: true,
                showTrails: true, bloomStrength: 2.5, bloomRadius: 0.6, bloomThreshold: 0.0,
                paused: false, autoRotate: true
            },
            'Neon Rainbow': {
                spawnRate: 15, inboundSpeed: 0.06, crawlSpeed: 0.012,
                turnChance: 8, crawlerLifeSec: 6, trailFadeSec: 3,
                trailColor: '#ffffff', multiColor: true, headSize: 0.04, showHeads: true,
                showTrails: true, bloomStrength: 3.0, bloomRadius: 0.8, bloomThreshold: 0.0,
                paused: false, autoRotate: true
            }
        };

        const MAX_LINES = 100000;
        const ASSUMED_FPS = 60; // For converting seconds to frames

        // Global Data - now an array of SDF objects
        const sdfs = [];
        let spawnAcc = 0;

        // Particle System
        const particles = []; 
        let lineIdx = 0;

        // Sample SDF at a local coordinate (within [-1,1] bounds of the SDF)
        function sampleSDFLocal(sdf, x, y, z) {
            const { data, resolution } = sdf;
            // Map x,y,z from [-1, 1] to [0, resolution-1]
            const u = (x + 1) * 0.5;
            const v = (y + 1) * 0.5;
            const w = (z + 1) * 0.5;

            if(u < 0 || u >= 1 || v < 0 || v >= 1 || w < 0 || w >= 1) return 1.0;

            const gx = u * (resolution - 1);
            const gy = v * (resolution - 1);
            const gz = w * (resolution - 1);

            const ix = Math.floor(gx);
            const iy = Math.floor(gy);
            const iz = Math.floor(gz);

            const fx = gx - ix;
            const fy = gy - iy;
            const fz = gz - iz;

            const getVal = (x, y, z) => {
                x = Math.max(0, Math.min(resolution - 1, x));
                y = Math.max(0, Math.min(resolution - 1, y));
                z = Math.max(0, Math.min(resolution - 1, z));
                return data[z * resolution * resolution + y * resolution + x];
            }

            const c000 = getVal(ix, iy, iz);
            const c100 = getVal(ix+1, iy, iz);
            const c010 = getVal(ix, iy+1, iz);
            const c110 = getVal(ix+1, iy+1, iz);
            const c001 = getVal(ix, iy, iz+1);
            const c101 = getVal(ix+1, iy, iz+1);
            const c011 = getVal(ix, iy+1, iz+1);
            const c111 = getVal(ix+1, iy+1, iz+1);

            const i1 = c000 * (1 - fx) + c100 * fx;
            const i2 = c010 * (1 - fx) + c110 * fx;
            const j1 = i1 * (1 - fy) + i2 * fy;

            const i3 = c001 * (1 - fx) + c101 * fx;
            const i4 = c011 * (1 - fx) + c111 * fx;
            const j2 = i3 * (1 - fy) + i4 * fy;

            return j1 * (1 - fz) + j2 * fz;
        }

        // Convert world position to SDF local coordinates (accounting for rotation)
        function worldToLocal(sdf, worldPos) {
            // Translate to origin
            const translated = new THREE.Vector3(
                worldPos.x - sdf.position.x,
                worldPos.y - sdf.position.y,
                worldPos.z - sdf.position.z
            );

            // Apply inverse rotation if present
            if (sdf.rotation) {
                const invQuat = new THREE.Quaternion().setFromEuler(sdf.rotation).invert();
                translated.applyQuaternion(invQuat);
            }

            // Scale
            return translated.divideScalar(sdf.scale);
        }

        // Convert SDF local coordinates to world position (accounting for rotation)
        function localToWorld(sdf, localPos) {
            // Scale first
            const scaled = localPos.clone().multiplyScalar(sdf.scale);

            // Apply rotation if present
            if (sdf.rotation) {
                const quat = new THREE.Quaternion().setFromEuler(sdf.rotation);
                scaled.applyQuaternion(quat);
            }

            // Translate
            return scaled.add(sdf.position);
        }

        // Sample SDF at world coordinates
        function sampleSDFWorld(sdf, worldX, worldY, worldZ) {
            const local = worldToLocal(sdf, new THREE.Vector3(worldX, worldY, worldZ));
            return sampleSDFLocal(sdf, local.x, local.y, local.z) * sdf.scale;
        }

        // Get normal at local coordinates
        function getNormalLocal(sdf, x, y, z) {
            const e = 0.01;
            const dx = sampleSDFLocal(sdf, x + e, y, z) - sampleSDFLocal(sdf, x - e, y, z);
            const dy = sampleSDFLocal(sdf, x, y + e, z) - sampleSDFLocal(sdf, x, y - e, z);
            const dz = sampleSDFLocal(sdf, x, y, z + e) - sampleSDFLocal(sdf, x, y, z - e);
            const n = new THREE.Vector3(dx, dy, dz);
            return n.normalize();
        }

        async function init() {
            // Scene
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 1.5); // Moved closer to see details

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = params.autoRotate;
            controls.autoRotateSpeed = 1.0;

            // Load all SDFs
            document.getElementById('info').textContent = 'Amove Games...';
            for (const config of SDF_CONFIGS) {
                const metaRes = await fetch(config.metaPath);
                const meta = await metaRes.json();

                const binRes = await fetch(config.binPath);
                const binBuffer = await binRes.arrayBuffer();
                const data = new Float32Array(binBuffer);

                sdfs.push({
                    name: config.name,
                    data: data,
                    resolution: meta.resolution,
                    position: config.position.clone(),
                    scale: config.scale
                });

                console.log(`Loaded SDF: ${config.name} (${meta.resolution}^3)`);
            }

            document.getElementById('info').textContent = 'Amove Games...';

            // Particles (Heads) with per-vertex colors, sizes, and opacity
            const MAX_PARTICLES = 5000;
            const pGeo = new THREE.BufferGeometry();
            const pPosAttr = new THREE.BufferAttribute(new Float32Array(MAX_PARTICLES * 3), 3);
            const pColorAttr = new THREE.BufferAttribute(new Float32Array(MAX_PARTICLES * 3), 3);
            const pSizeAttr = new THREE.BufferAttribute(new Float32Array(MAX_PARTICLES), 1);
            const pAlphaAttr = new THREE.BufferAttribute(new Float32Array(MAX_PARTICLES), 1);
            pPosAttr.setUsage(THREE.DynamicDrawUsage);
            pColorAttr.setUsage(THREE.DynamicDrawUsage);
            pSizeAttr.setUsage(THREE.DynamicDrawUsage);
            pAlphaAttr.setUsage(THREE.DynamicDrawUsage);
            pGeo.setAttribute('position', pPosAttr);
            pGeo.setAttribute('color', pColorAttr);
            pGeo.setAttribute('size', pSizeAttr);
            pGeo.setAttribute('alpha', pAlphaAttr);

            const pMat = new THREE.ShaderMaterial({
                uniforms: {
                    uBaseSize: { value: params.headSize * 5 } // Scale for gl_PointSize
                },
                vertexShader: `
                    attribute vec3 color;
                    attribute float size;
                    attribute float alpha;
                    varying vec3 vColor;
                    varying float vAlpha;
                    uniform float uBaseSize;
                    void main() {
                        vColor = color;
                        vAlpha = alpha;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * uBaseSize * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        // Circular point with soft edge
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        if (dist > 0.5) discard;
                        float softEdge = 1.0 - smoothstep(0.3, 0.5, dist);
                        gl_FragColor = vec4(vColor, vAlpha * softEdge);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            const pSys = new THREE.Points(pGeo, pMat);
            pSys.visible = params.showHeads; // Initialize visibility from params
            scene.add(pSys);

            // Trails (Lines) with ShaderMaterial for opacity and per-vertex colors
            const lGeo = new THREE.BufferGeometry();
            const lPos = new Float32Array(MAX_LINES * 6); // 2 points per line, 3 coords
            const lLife = new Float32Array(MAX_LINES * 2); // 1 float per vertex
            const lColors = new Float32Array(MAX_LINES * 6); // 2 points per line, 3 color components (RGB)
            const lBrightness = new Float32Array(MAX_LINES * 2); // 1 float per vertex for brightness

            const posAttr = new THREE.BufferAttribute(lPos, 3);
            const lifeAttr = new THREE.BufferAttribute(lLife, 1);
            const colorAttr = new THREE.BufferAttribute(lColors, 3);
            const brightnessAttr = new THREE.BufferAttribute(lBrightness, 1);

            // CRITICAL: Set usage to DynamicDrawUsage for frequent updates
            posAttr.setUsage(THREE.DynamicDrawUsage);
            lifeAttr.setUsage(THREE.DynamicDrawUsage);
            colorAttr.setUsage(THREE.DynamicDrawUsage);
            brightnessAttr.setUsage(THREE.DynamicDrawUsage);

            lGeo.setAttribute('position', posAttr);
            lGeo.setAttribute('life', lifeAttr);
            lGeo.setAttribute('color', colorAttr);
            lGeo.setAttribute('brightness', brightnessAttr);
            lGeo.setDrawRange(0, 0);

            const lMat = new THREE.ShaderMaterial({
                uniforms: {
                    uBaseColor: { value: new THREE.Color(params.trailColor) },
                    uMultiColor: { value: params.multiColor ? 1.0 : 0.0 }
                },
                vertexShader: `
                    attribute float life;
                    attribute vec3 color;
                    attribute float brightness;
                    varying float vAlpha;
                    varying vec3 vColor;
                    varying float vBrightness;
                    void main() {
                        vAlpha = life;
                        vColor = color;
                        vBrightness = brightness;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uBaseColor;
                    uniform float uMultiColor;
                    varying float vAlpha;
                    varying vec3 vColor;
                    varying float vBrightness;
                    void main() {
                        if(vAlpha <= 0.0) discard;
                        // Mix between base color and per-vertex color based on uMultiColor
                        vec3 finalColor = mix(uBaseColor, vColor, uMultiColor);
                        // Apply brightness multiplier to simulate varying line thickness
                        gl_FragColor = vec4(finalColor * vBrightness, vAlpha * vBrightness);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            const lSys = new THREE.LineSegments(lGeo, lMat);
            lSys.visible = params.showTrails; // Initialize visibility from params
            scene.add(lSys);

            // Bloom post-processing
            const composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                params.bloomStrength,
                params.bloomRadius,
                params.bloomThreshold
            );
            composer.addPass(bloomPass);

            // Handle window resize for composer
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // Track how many lines have been added (for proper draw range management)
            let totalLinesAdded = 0;

            // GUI (after materials are created)
            // const gui = new GUI({ width: 280 }); // Debug GUI disabled for production

            // GUI disabled for production

            // Helper to convert HSL to RGB
            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return { r, g, b };
            }

            // Find a random point on a specific SDF's surface using gradient descent
            // Returns local coordinates within the SDF
            function findSurfacePoint(sdf) {
                // Start from a random point in the bounding box [-1, 1]
                let x = (Math.random() * 2 - 1) * 0.95;
                let y = (Math.random() * 2 - 1) * 0.95;
                let z = (Math.random() * 2 - 1) * 0.95;

                // March toward the surface using the SDF gradient
                const maxIterations = 50;
                for (let i = 0; i < maxIterations; i++) {
                    const dist = sampleSDFLocal(sdf, x, y, z);

                    // Close enough to surface
                    if (Math.abs(dist) < 0.01) {
                        // Final snap to surface
                        const n = getNormalLocal(sdf, x, y, z);
                        x -= n.x * dist;
                        y -= n.y * dist;
                        z -= n.z * dist;
                        return { x, y, z, valid: true };
                    }

                    // Move toward surface along the gradient (normal)
                    const n = getNormalLocal(sdf, x, y, z);
                    // Step size is the distance to surface (sphere tracing)
                    x -= n.x * dist;
                    y -= n.y * dist;
                    z -= n.z * dist;

                    // Check if we've gone out of bounds
                    if (Math.abs(x) > 1.1 || Math.abs(y) > 1.1 || Math.abs(z) > 1.1) {
                        return { x: 0, y: 0, z: 0, valid: false };
                    }
                }

                return { x: 0, y: 0, z: 0, valid: false };
            }

            function spawnParticle() {
                // Pick a random SDF to spawn on
                const sdf = sdfs[Math.floor(Math.random() * sdfs.length)];

                // Find a random point on the surface (in local coordinates)
                const surfacePoint = findSurfacePoint(sdf);
                if (!surfacePoint.valid) return; // Failed to find surface, skip this spawn

                // Convert local position to world position
                const localPos = new THREE.Vector3(surfacePoint.x, surfacePoint.y, surfacePoint.z);
                const worldPos = localToWorld(sdf, localPos);

                // Get surface normal and cardinal directions at spawn point (in local space)
                const n = getNormalLocal(sdf, surfacePoint.x, surfacePoint.y, surfacePoint.z);
                const cardinals = getCardinalDirections(n);

                // Pick a random cardinal direction to start crawling
                const [t1, t2] = cardinals;
                const dirChoice = Math.floor(Math.random() * 4);
                let vel;
                switch (dirChoice) {
                    case 0: vel = t1.clone(); break;
                    case 1: vel = t1.clone().negate(); break;
                    case 2: vel = t2.clone(); break;
                    case 3: vel = t2.clone().negate(); break;
                }
                vel.multiplyScalar(params.crawlSpeed * sdf.scale);

                // Generate a random vibrant color (high saturation, medium lightness)
                const hue = Math.random();
                const color = hslToRgb(hue, 1.0, 0.5);

                // Randomize size and opacity for variety
                const size = 0.3 + Math.random() * 0.7;   // 0.3 to 1.0 multiplier
                const alpha = 0.5 + Math.random() * 0.5;  // 0.5 to 1.0 opacity
                const brightness = 0.7 + Math.random() * 0.3; // 0.7 to 1.0 trail brightness

                particles.push({
                    pos: worldPos,
                    vel: vel,
                    sdf: sdf, // Track which SDF this particle belongs to
                    state: 'crawler', // Start directly as crawler since we're on surface
                    life: Math.round(params.crawlerLifeSec * ASSUMED_FPS),
                    color: color,
                    size: size,
                    alpha: alpha,
                    brightness: brightness
                });
            }

            const vec3 = new THREE.Vector3();
            const normal = new THREE.Vector3();
            const tangent = new THREE.Vector3();

            // Compute stable cardinal directions on the surface at a given point
            // Returns two orthogonal tangent vectors that stay consistent across the surface
            function getCardinalDirections(n) {
                // Use world-up as reference to create consistent "horizontal" direction
                const worldUp = new THREE.Vector3(0, 1, 0);

                // If normal is nearly parallel to world-up, use world-forward instead
                const tangent1 = new THREE.Vector3();
                if (Math.abs(n.dot(worldUp)) > 0.9) {
                    tangent1.crossVectors(n, new THREE.Vector3(0, 0, 1)).normalize();
                } else {
                    tangent1.crossVectors(n, worldUp).normalize();
                }

                // Second tangent is perpendicular to both normal and first tangent
                const tangent2 = new THREE.Vector3().crossVectors(n, tangent1).normalize();

                return [tangent1, tangent2];
            }

            // Snap velocity to nearest cardinal direction on the surface
            function snapToCardinal(vel, cardinals) {
                const [t1, t2] = cardinals;

                // Project velocity onto the two cardinal axes
                const dot1 = vel.dot(t1);
                const dot2 = vel.dot(t2);

                // Choose the axis with stronger alignment
                if (Math.abs(dot1) >= Math.abs(dot2)) {
                    return t1.clone().multiplyScalar(Math.sign(dot1) || 1);
                } else {
                    return t2.clone().multiplyScalar(Math.sign(dot2) || 1);
                }
            }

            // Turn 90 degrees in a cardinal direction
            function turnCardinal(currentDir, cardinals, direction) {
                const [t1, t2] = cardinals;

                // Find which cardinal we're currently aligned to
                const dot1 = Math.abs(currentDir.dot(t1));
                const dot2 = Math.abs(currentDir.dot(t2));

                // Turn to the other axis
                if (dot1 > dot2) {
                    // Currently on t1 axis, turn to t2
                    return t2.clone().multiplyScalar(direction);
                } else {
                    // Currently on t2 axis, turn to t1
                    return t1.clone().multiplyScalar(direction);
                }
            }

            function update() {
                // Spawn - convert from particles/sec to particles/frame
                const spawnPerFrame = params.spawnRate / ASSUMED_FPS;
                spawnAcc += spawnPerFrame;
                while(spawnAcc >= 1 && particles.length < MAX_PARTICLES) {
                    spawnParticle();
                    spawnAcc -= 1;
                }

                // Update Trail Fading
                const lifes = lGeo.attributes.life.array;

                const trailFadeFrames = Math.max(1, params.trailFadeSec * ASSUMED_FPS);
                const decay = 1.0 / trailFadeFrames;

                // Iterate over all potentially active line vertices
                const activeVertices = Math.min(totalLinesAdded * 2, MAX_LINES * 2);
                for(let i = 0; i < activeVertices; i++) {
                    if(lifes[i] > 0) {
                        lifes[i] -= decay;
                        if(lifes[i] < 0) lifes[i] = 0;
                    }
                }
                lGeo.attributes.life.needsUpdate = true;

                const positions = lGeo.attributes.position.array;
                const colors = lGeo.attributes.color.array;

                for(let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    const sdf = p.sdf; // Get the SDF this particle belongs to

                    // All particles are now crawlers (spawned directly on surface)
                    const prevPos = p.pos.clone();

                    // Move
                    p.pos.add(p.vel);

                    // Convert world position to local for SDF sampling
                    const localPos = worldToLocal(sdf, p.pos);

                    // Stick to surface
                    const dist = sampleSDFLocal(sdf, localPos.x, localPos.y, localPos.z);
                    const n = getNormalLocal(sdf, localPos.x, localPos.y, localPos.z);
                    // Adjust position in world space
                    p.pos.sub(n.clone().multiplyScalar(dist * sdf.scale));

                    // Check if crawler went off the surface (out of bounds in local space)
                    const newLocalPos = worldToLocal(sdf, p.pos);
                    if (Math.abs(dist) > 0.1 ||
                        Math.abs(newLocalPos.x) > 1.2 ||
                        Math.abs(newLocalPos.y) > 1.2 ||
                        Math.abs(newLocalPos.z) > 1.2) {
                        particles.splice(i, 1);
                        continue;
                    }

                    // Add Trail
                    const idx = lineIdx * 6; // 6 floats per line (2 verts * 3 pos)
                    const lifeIdx = lineIdx * 2;

                    positions[idx] = prevPos.x;
                    positions[idx+1] = prevPos.y;
                    positions[idx+2] = prevPos.z;

                    positions[idx+3] = p.pos.x;
                    positions[idx+4] = p.pos.y;
                    positions[idx+5] = p.pos.z;

                    // Reset life for this new segment
                    lifes[lifeIdx] = 1.0;
                    lifes[lifeIdx+1] = 1.0;

                    // Set color for both vertices of this line segment
                    const colorIdx = lineIdx * 6;
                    colors[colorIdx] = p.color.r;
                    colors[colorIdx + 1] = p.color.g;
                    colors[colorIdx + 2] = p.color.b;
                    colors[colorIdx + 3] = p.color.r;
                    colors[colorIdx + 4] = p.color.g;
                    colors[colorIdx + 5] = p.color.b;

                    // Set brightness for both vertices
                    const brightnesses = lGeo.attributes.brightness.array;
                    brightnesses[lifeIdx] = p.brightness;
                    brightnesses[lifeIdx + 1] = p.brightness;

                    lineIdx = (lineIdx + 1) % MAX_LINES;
                    totalLinesAdded++;

                    // Update draw range (cap at MAX_LINES)
                    const newDrawCount = Math.min(totalLinesAdded, MAX_LINES) * 2;
                    lGeo.setDrawRange(0, newDrawCount);

                    lGeo.attributes.position.needsUpdate = true;
                    lGeo.attributes.color.needsUpdate = true;
                    lGeo.attributes.brightness.needsUpdate = true;

                    // Get cardinal directions at current position
                    const cardinals = getCardinalDirections(n);

                    // Turn Logic - always stay on cardinal directions
                    const speedWithScale = params.crawlSpeed * sdf.scale;
                    if(Math.random() < params.turnChance / 100) {
                        // Turn 90 degrees left or right
                        const turnDir = Math.random() < 0.5 ? 1 : -1;
                        p.vel = turnCardinal(p.vel, cardinals, turnDir).multiplyScalar(speedWithScale);
                    } else {
                        // Re-snap to cardinal to correct any drift from surface curvature
                        p.vel = snapToCardinal(p.vel, cardinals).multiplyScalar(speedWithScale);
                    }

                    p.life--;
                    if(p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }

                // Update particle heads (all particles are crawlers now)
                const pPos = pGeo.attributes.position.array;
                const pColors = pGeo.attributes.color.array;
                const pSizes = pGeo.attributes.size.array;
                const pAlphas = pGeo.attributes.alpha.array;
                for(let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    pPos[i * 3] = p.pos.x;
                    pPos[i * 3 + 1] = p.pos.y;
                    pPos[i * 3 + 2] = p.pos.z;
                    // Use particle's color if multiColor is enabled, otherwise use base color
                    if (params.multiColor) {
                        pColors[i * 3] = p.color.r;
                        pColors[i * 3 + 1] = p.color.g;
                        pColors[i * 3 + 2] = p.color.b;
                    } else {
                        const baseColor = new THREE.Color(params.trailColor);
                        pColors[i * 3] = baseColor.r;
                        pColors[i * 3 + 1] = baseColor.g;
                        pColors[i * 3 + 2] = baseColor.b;
                    }
                    // Set per-particle size and alpha
                    pSizes[i] = p.size;
                    pAlphas[i] = p.alpha;
                }
                pGeo.setDrawRange(0, particles.length);
                pGeo.attributes.position.needsUpdate = true;
                pGeo.attributes.color.needsUpdate = true;
                pGeo.attributes.size.needsUpdate = true;
                pGeo.attributes.alpha.needsUpdate = true;
            }

            // FPS tracking
            let frameCount = 0;
            let lastFpsUpdate = performance.now();
            let currentFps = 0;

            // Stats DOM elements
            const fpsEl = document.getElementById('fps');
            const particleCountEl = document.getElementById('particleCount');
            const lineCountEl = document.getElementById('lineCount');

            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                // Only update simulation if not paused
                if (!params.paused) {
                    update();
                }

                composer.render();

                // FPS calculation
                frameCount++;
                const now = performance.now();
                if (now - lastFpsUpdate >= 500) { // Update every 500ms
                    currentFps = Math.round(frameCount / ((now - lastFpsUpdate) / 1000));
                    frameCount = 0;
                    lastFpsUpdate = now;

                    // Update stats display
                    fpsEl.textContent = currentFps;
                    particleCountEl.textContent = particles.length;
                    lineCountEl.textContent = Math.floor(lGeo.drawRange.count / 2).toLocaleString();
                }
            }
            animate();
        }

        init().catch(err => console.error(err));
    </script>
</body>
</html>
