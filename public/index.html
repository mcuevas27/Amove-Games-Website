<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Move Games | Protocol</title>
    <link rel="stylesheet" href="../src/css/style.css">
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Fixed Background -->
    <div id="canvas-container"></div>



    <!-- Scrollable Content -->
    <main>
        <!-- Hero Section -->
        <section class="section-hero">
            <div class="hero-title">
                <span class="text-scanline title-white">A-MOVE</span>
                <span class="text-scanline title-cyan">GAMES</span>
            </div>
            <div class="hero-subtitle">EST. 2026</div>
            <div class="hero-quote">Fast Action Real-Time Strategy Rebooted.</div>
        </section>


    </main>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- SHADERS INLINED ---
        const fogVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fogFragmentShader = `
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            uniform sampler2D uVisionTexture;

            varying vec2 vUv;

            void main() {
                // Simple solid fog color - Deep Space Black
                vec3 fogColor = vec3(0.02, 0.02, 0.05);

                // Sample vision texture
                vec4 vision = texture2D(uVisionTexture, vUv);
                float clearFactor = vision.r;

                // Smooth edge transition (Softened)
                float revealed = smoothstep(0.0, 0.8, clearFactor);

                // Fog alpha - slightly transparent to show hints of map
                float alpha = 0.95 * (1.0 - revealed);

                gl_FragColor = vec4(fogColor, alpha);
            }
        `;

        // --- MAP SHADER (Procedural Hexagon Map) ---
        const mapFragmentShader = `
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            uniform float uTime;
            uniform sampler2D uVisionTexture;
            
            // Customizable Uniforms
            uniform vec3 uColorWater;
            uniform vec3 uColorGrass;
            uniform vec3 uColorDirt;
            uniform vec3 uColorWaterGlow;
            uniform vec3 uColorGrassGlow;
            uniform vec3 uColorDirtGlow;
            
            uniform float uGapSize;
            uniform float uOutlineWidth;
            uniform float uOutlineOpacity;

            varying vec2 vUv;

            // Hexagon Grid Logic
            vec4 hexCoords(vec2 uv) {
                vec2 r = vec2(1.0, 1.73);
                vec2 h = r * 0.5;

                vec2 a = mod(uv, r) - h;
                vec2 b = mod(uv - h, r) - h;

                vec2 gv = dot(a, a) < dot(b, b) ? a : b;

                float x = abs(gv.x);
                float y = abs(gv.y);
                float dist = 0.5 * r.x - max(x, x * 0.5 + y * 0.866);

                vec2 id = uv - gv;

                return vec4(id, dist, 0.0);
            }

            void main() {
                vec2 uv = vUv * 20.0;

                vec4 h = hexCoords(uv);
                vec2 id = h.xy;
                float dist = h.z;

                // Integer-based terrain selection using mod
                vec2 intId = floor(id + 0.5);
                float terrainIndex = mod(intId.x + intId.y * 2.0, 3.0);

                // Values from Uniforms
                vec3 water = uColorWater;
                vec3 grass = uColorGrass;
                vec3 dirt = uColorDirt;
                vec3 waterGlow = uColorWaterGlow;
                vec3 grassGlow = uColorGrassGlow;
                vec3 dirtGlow = uColorDirtGlow;

                // Select base color
                float isWater = 1.0 - step(0.5, terrainIndex);
                float isGrass = step(0.5, terrainIndex) * (1.0 - step(1.5, terrainIndex));
                float isDirt = step(1.5, terrainIndex);

                vec3 themeColor = water * isWater + grass * isGrass + dirt * isDirt;
                vec3 glowColor = waterGlow * isWater + grassGlow * isGrass + dirtGlow * isDirt;

                // --- ISOLATED TILES (HOLLOW OUTLINES) ---
                float gapSize = uGapSize;
                float hexMask = smoothstep(gapSize, gapSize + 0.02, dist);
                
                float outlineWidth = uOutlineWidth;
                float innerEdge = gapSize + outlineWidth;
                float innerMask = smoothstep(innerEdge, innerEdge + 0.02, dist);
                float borderMask = hexMask - innerMask;
                
                // Base tile - muted
                vec3 col = themeColor * borderMask * uOutlineOpacity; 
                
                // --- GLOW EFFECT WHEN REVEALED ---
                vec2 centerUv = id / 20.0;
                float revealed = texture2D(uVisionTexture, centerUv).r;

                float brightness = smoothstep(0.05, 0.6, revealed);

                // When revealed, brighten the outline heavily
                col += glowColor * borderMask * brightness * 0.9; 

                // Interactive Glow
                col += glowColor * 0.4 * brightness * borderMask;

                // Rim highlight 
                float rim = smoothstep(gapSize, gapSize + 0.02, dist) * (1.0 - smoothstep(gapSize + 0.02, gapSize + 0.04, dist));
                col += glowColor * rim * brightness * 0.6;
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const mainUniforms = {
            uTime: { value: 0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uMouse: { value: new THREE.Vector2(0.5, 0.5) },
            uVisionTexture: { value: null },
            // Configurable
            uColorWater: { value: new THREE.Color('#3e78b6') },
            uColorGrass: { value: new THREE.Color('#3ba2ce') },
            uColorDirt: { value: new THREE.Color('#e6b919') },
            uColorWaterGlow: { value: new THREE.Color('#73c5ce') },
            uColorGrassGlow: { value: new THREE.Color('#3f60e4') },
            uColorDirtGlow: { value: new THREE.Color('#9d6aa4') },
            uGapSize: { value: 0.0888 },
            uOutlineWidth: { value: 0.001 },
            uOutlineOpacity: { value: 0.321 }
        };

        // --- MAP SQUAD ---
        const mapGeo = new THREE.PlaneGeometry(2, 2);
        const mapMat = new THREE.ShaderMaterial({
            uniforms: mainUniforms,
            vertexShader: fogVertexShader,
            fragmentShader: mapFragmentShader
        });
        const mapPlane = new THREE.Mesh(mapGeo, mapMat);
        mapPlane.position.z = -0.1; 
        scene.add(mapPlane);

        // --- FOG PERSISTENCE SYSTEM ---
        const visionScene = new THREE.Scene();
        const visionCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const visionBrushGeo = new THREE.PlaneGeometry(0.5, 0.5); 
        const visionBrushMat = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                void main() {
                    float dist = length(vUv - 0.5);
                    float intensity = 1.0 - smoothstep(0.0, 0.5, dist);
                    intensity = pow(intensity, 2.0);
                    gl_FragColor = vec4(intensity, 0.0, 0.0, 1.0);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending 
        });
        const visionBrush = new THREE.Mesh(visionBrushGeo, visionBrushMat);
        visionScene.add(visionBrush);

        const persistenceScene = new THREE.Scene();
        const persistenceQuadVec = new THREE.PlaneGeometry(2, 2);
        
        const persistenceShader = {
            uniforms: {
                tDiffuse: { value: null },
                uDecay: { value: 0.012 } 
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float uDecay;
                varying vec2 vUv;
                void main() {
                    vec4 texel = texture2D(tDiffuse, vUv);
                    float val = texel.r - uDecay;
                    gl_FragColor = vec4(val, val, val, 1.0);
                }
            `
        };
        
        const persistenceMat = new THREE.ShaderMaterial({
            uniforms: persistenceShader.uniforms,
            vertexShader: persistenceShader.vertexShader,
            fragmentShader: persistenceShader.fragmentShader
        });
        const persistenceQuad = new THREE.Mesh(persistenceQuadVec, persistenceMat);
        persistenceScene.add(persistenceQuad);

        // Render Targets
        const rtParams = { 
            minFilter: THREE.LinearFilter, 
            magFilter: THREE.LinearFilter, 
            format: THREE.RGBAFormat,
            type: THREE.FloatType 
        };
        let rtA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
        let rtB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);

        // --- MAIN SCENE ---
        const planeGeo = new THREE.PlaneGeometry(2, 2);
        const mainMat = new THREE.ShaderMaterial({
            uniforms: mainUniforms,
            vertexShader: fogVertexShader,
            fragmentShader: fogFragmentShader,
            transparent: true
        });

        const mainPlane = new THREE.Mesh(planeGeo, mainMat);
        const fogScene = new THREE.Scene();
        fogScene.add(mainPlane);

        // --- INTERACTION ---
        const mouse = new THREE.Vector2(-10, -10); 
        visionBrush.position.set(-10, -10, 0);

        document.addEventListener('mousemove', (e) => {
            // Normalized Mouse for Vision Brush (which is in -1 to 1 space)
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // Update Shader Uniform
            mainUniforms.uMouse.value.x = e.clientX / window.innerWidth;
            mainUniforms.uMouse.value.y = 1.0 - (e.clientY / window.innerHeight);

            // Move Vision Brush
            visionBrush.position.set(mouse.x, mouse.y, 0);
        });

        // Resize
        window.addEventListener('resize', () => {
             const w = window.innerWidth;
             const h = window.innerHeight;
             renderer.setSize(w, h);
             rtA.setSize(w, h);
             rtB.setSize(w, h);
             mainUniforms.uResolution.value.set(w, h);
             const aspect = w / h;
             visionBrush.scale.set(1, aspect, 1);
        });
        
        visionBrush.scale.set(1, window.innerWidth/window.innerHeight, 1);

        // A-Move Click Effect
        document.addEventListener('click', (e) => {
            spawnAMoveMarker(e.clientX, e.clientY + window.scrollY); // Account for scroll
        });

        function spawnAMoveMarker(x, y) {
            const marker = document.createElement('div');
            marker.className = 'amove-marker';
            marker.style.left = x + 'px';
            marker.style.top = y + 'px';
            
            for(let i=0; i<4; i++) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                if (i===0) arrow.style.setProperty('--angle', '0deg');
                if (i===1) arrow.style.setProperty('--angle', '90deg');
                if (i===2) arrow.style.setProperty('--angle', '180deg');
                if (i===3) arrow.style.setProperty('--angle', '270deg');
                marker.appendChild(arrow);
            }
            
            document.body.appendChild(marker);
            
            setTimeout(() => {
                marker.remove();
            }, 500);
        }

        // Initialize Clock
        const clock = new THREE.Clock();

        // --- POST PROCESSING USELESS FOR FIXED BG BUT GOOD FOR BLOOM ---
        const composer = new EffectComposer(renderer);
        
        const mapPass = new RenderPass(scene, camera);
        composer.addPass(mapPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            1.5,   // Strength
            0.1,  // Radius
            0.3    // Threshold
        );
        composer.addPass(bloomPass);

        // --- DEBUG GUI ---
        const gui = new GUI({ title: 'A-Move Debug' });
        
        const settings = {
            water: '#050d1a',
            grass: '#05141f',
            dirt: '#0d0526',
            waterGlow: '#00ccff',
            grassGlow: '#0080ff',
            dirtGlow: '#9900ff',
            export: function() {
                const config = {
                    colors: {
                        water: settings.water,
                        grass: settings.grass,
                        dirt: settings.dirt,
                        waterGlow: settings.waterGlow,
                        grassGlow: settings.grassGlow,
                        dirtGlow: settings.dirtGlow
                    },
                    geometry: {
                        gapSize: mainUniforms.uGapSize.value,
                        outlineWidth: mainUniforms.uOutlineWidth.value,
                        outlineOpacity: mainUniforms.uOutlineOpacity.value
                    },
                    typography: {
                        scanThickness: settings.scanThickness,
                        scanGap: settings.scanGap,
                        titleGlow: settings.titleGlow
                    }
                };
                const json = JSON.stringify(config, null, 2);
                console.log("--- SAVED CONFIG ---");
                console.log(json);
                alert("Settings exported to Console (F12)!");
            },
            // Typography State
            scanThickness: 6.66,
            scanGap: 0,
            titleGlow: 13.6
        };

        // Sync Helper
        function updateColor(name, uniform) {
            mainUniforms[uniform].value.set(settings[name]);
        }
        function updateCSS(varName, value, unit='px') {
            document.documentElement.style.setProperty(varName, value + unit);
        }

        // Initialize gui with current uniform values
        settings.water = '#' + mainUniforms.uColorWater.value.getHexString();
        settings.grass = '#' + mainUniforms.uColorGrass.value.getHexString();
        settings.dirt = '#' + mainUniforms.uColorDirt.value.getHexString();
        settings.waterGlow = '#' + mainUniforms.uColorWaterGlow.value.getHexString();
        settings.grassGlow = '#' + mainUniforms.uColorGrassGlow.value.getHexString();
        settings.dirtGlow = '#' + mainUniforms.uColorDirtGlow.value.getHexString();

        const fColors = gui.addFolder('Theme Colors');
        fColors.addColor(settings, 'water').name('Base 1 (Water)').onChange(() => updateColor('water', 'uColorWater'));
        fColors.addColor(settings, 'grass').name('Base 2 (Grass)').onChange(() => updateColor('grass', 'uColorGrass'));
        fColors.addColor(settings, 'dirt').name('Base 3 (Dirt)').onChange(() => updateColor('dirt', 'uColorDirt'));
        
        const fGlow = gui.addFolder('Glow Colors');
        fGlow.addColor(settings, 'waterGlow').name('Glow 1').onChange(() => updateColor('waterGlow', 'uColorWaterGlow'));
        fGlow.addColor(settings, 'grassGlow').name('Glow 2').onChange(() => updateColor('grassGlow', 'uColorGrassGlow'));
        fGlow.addColor(settings, 'dirtGlow').name('Glow 3').onChange(() => updateColor('dirtGlow', 'uColorDirtGlow'));

        const fGeo = gui.addFolder('Geometry');
        fGeo.add(mainUniforms.uGapSize, 'value', 0.0, 0.2).name('Gap Size');
        fGeo.add(mainUniforms.uOutlineWidth, 'value', 0.001, 0.1).name('Outline Width');
        fGeo.add(mainUniforms.uOutlineOpacity, 'value', 0.0, 1.0).name('Base Opacity');

        const fTypo = gui.addFolder('Typography');
        fTypo.add(settings, 'scanThickness', 1, 10).name('Scan Thickness').onChange(v => updateCSS('--scan-thickness', v));
        fTypo.add(settings, 'scanGap', 0, 10).name('Scan Gap').onChange(v => updateCSS('--scan-gap', v));
        fTypo.add(settings, 'titleGlow', 0, 50).name('Title Glow').onChange(v => updateCSS('--title-glow', v));

        const fBloom = gui.addFolder('Bloom');
        fBloom.add(bloomPass, 'strength', 0.0, 5.0).name('Strength');
        fBloom.add(bloomPass, 'radius', 0.0, 1.0).name('Radius');
        fBloom.add(bloomPass, 'threshold', 0.0, 1.0).name('Threshold');

        gui.add(settings, 'export').name('ðŸ’¾ EXPORT SETTINGS');

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            mainUniforms.uTime.value = clock.getElapsedTime();

            // Step 1: Decay (rtB -> rtA)
            persistenceMat.uniforms.tDiffuse.value = rtB.texture;
            renderer.setRenderTarget(rtA);
            renderer.render(persistenceScene, visionCamera);
            
            // Step 2: Draw Brush (Additively on top of rtA)
            renderer.autoClear = false; 
            renderer.render(visionScene, visionCamera);
            renderer.autoClear = true; 

            // Step 3: Composer Rendering (Map + Bloom)
            mainUniforms.uVisionTexture.value = rtA.texture;
            
            composer.render();

            // Step 4: Render Fog (No Bloom, On Top)
            renderer.setRenderTarget(null); 
            renderer.autoClear = false;
            renderer.clearDepth();
            renderer.render(fogScene, camera);
            renderer.autoClear = true;

            // Swap Buffers
            let temp = rtA;
            rtA = rtB;
            rtB = temp;
        }
        animate();
    </script>
</body>
</html>
