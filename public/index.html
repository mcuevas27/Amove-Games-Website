<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Move Games | Protocol</title>
    <link rel="stylesheet" href="../src/css/style.css">
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Fixed Background -->
    <div id="canvas-container"></div>



    <!-- Scrollable Content -->
    <main>
        <!-- Hero Section -->
        <section class="section-hero">
            <div class="hero-title">
                <span><span class="text-scanline title-orange">A</span><span class="text-scanline title-white">-MOVE</span></span>
                <span class="text-scanline title-cyan">GAMES</span>
            </div>
            <div class="hero-subtitle">EST. 2026 USA//CANADA aka North North Dakota</div>
            <div class="hero-quote">Fast Action Real-Time Strategy Rebooted.</div>
        </section>

        <!-- Devs Section -->
        <section class="section-devs">
            <h2 class="text-scanline title-cyan">DEVS</h2>
        </section>

    </main>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- SHADERS INLINED ---
        const mapVertexShader = `
            varying vec2 vUv;
            varying vec2 vPos;
            
            void main() {
                vUv = uv;
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vPos = worldPosition.xy;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `;

        // --- SIMULATION SHADER (Ping Pong) ---
        // Handles the persistent "Mask" layer
        const simVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const simFragmentShader = `
            varying vec2 vUv;
            uniform sampler2D uTexture;
            uniform vec2 uMouse;
            uniform float uResolutionRatio; // Aspect Ratio Correction
            uniform float uCursorRadius;
            uniform float uDecay;
            uniform float uTime;
            
            void main() {
                // Sample previous frame
                vec4 prev = texture2D(uTexture, vUv);
                
                // Decay
                float value = prev.r * uDecay;
                
                // Brush (Mouse Interaction)
                // Correct for Aspect Ratio in distance calc
                vec2 aspectUV = vUv;
                aspectUV.x *= uResolutionRatio;
                
                vec2 aspectMouse = uMouse;
                aspectMouse.x *= uResolutionRatio;
                
                // Distance to brush
                float d = distance(aspectUV, aspectMouse);
                
                // Draw new 'paint'
                // uCursorRadius is in grid units in the main shader.
                // We'll approximate: 0.05 is a decent size in UV space relative to radius.
                float brush = 1.0 - smoothstep(0.0, uCursorRadius * 0.005, d); 
                
                // Add brush to value
                value = max(value, brush);
                
                // Clamp
                value = clamp(value, 0.0, 1.0);
                
                gl_FragColor = vec4(value, 0.0, 0.0, 1.0);
            }
        `;

        // --- HEXAGON PATTERN SHADER ---
        // Based on standard hex grid math
        const mapFragmentShader = `
            varying vec2 vUv;
            uniform float uTime;
            uniform float uScale;
            uniform float uStrokeWidth;
            uniform float uGap;
            uniform vec2 uResolution;
            
            // Pulse Uniforms
            uniform float uPulseSpeed;
            uniform float uPulseDensity; // 0.0 to 1.0 (roughly)
            uniform vec3 uPulseColor;
            
            // Stroke Colors
            uniform vec3 uStrokeColor1;
            uniform vec3 uStrokeColor2;
            uniform vec3 uStrokeColor3;
            
            // Interaction Texture (from Sim)
            uniform sampler2D uMask;

            // Pseudo-random hash
            float hash21(vec2 p) {
                p = fract(p * vec2(234.34, 435.345));
                p += dot(p, p + 34.23);
                return fract(p.x * p.y);
            }

            // Hexagon distance function
            float hexDist(vec2 p) {
                p = abs(p);
                // The dot product with (1, sqrt(3)) is the distance to the slanted edge
                float c = dot(p, normalize(vec2(1.0, 1.7320508)));
                // The max of that and the horizontal distance (p.x) gives the hex shape
                return max(c, p.x);
            }

            void main() {
                // Correct aspect ratio
                vec2 uv = vUv;
                uv.x *= uResolution.x / uResolution.y;
                
                // Scale
                uv *= uScale;
                
                // Read Interaction Mask from Texture
                // We read at vUv (uncorrected)
                float maskVal = texture2D(uMask, vUv).r;
                
                // Use the mask as our interaction factor
                float interact = smoothstep(0.01, 1.0, maskVal);

                // Standard hex tiling math:
                vec2 r = vec2(1.0, 1.7320508);
                vec2 h = r * 0.5;
                
                vec2 a = mod(uv, r) - h;
                vec2 b = mod(uv - h, r) - h;
                
                vec2 gv;
                if (length(a) < length(b))
                    gv = a; // 'a' is closer
                else
                    gv = b; // 'b' is closer
                
                // Identify the hex
                vec2 id = uv - gv;
                
                // Distance to edge
                float dist = hexDist(gv);
                
                float radius = 0.5;
                float outer = radius - uGap;
                float inner = outer - uStrokeWidth;
                
                // Fix for artifacts: use fwidth of the continuous UV coordinate instead of the discontinuous dist
                // The dist function has a gradient of 1.0 (it's a distance field), so the change in dist
                // per pixel is roughly the same as the change in UV per pixel.
                float aa = fwidth(uv.y); // uv is already scaled and aspect-corrected
                
                // Stroke mask
                float stroke = smoothstep(inner - aa, inner + aa, dist) - smoothstep(outer - aa, outer + aa, dist);
                
                // --- PULSE EFFECT ---
                float noise = hash21(id);
                // Generate a sine wave based on time and random offset
                // Range -1 to 1
                float rawPulse = sin(uTime * uPulseSpeed + noise * 100.0);
                
                // Thresholding to make it sparse
                // We want it to be 0 most of the time, and spike to 1
                // Map [-1, 1] to roughly [0, 1] but skewed
                
                float threshold = 1.0 - uPulseDensity; // e.g. density 0.1 -> threshold 0.9
                // If rawPulse > threshold, we light up
                float pulse = smoothstep(threshold, 1.0, rawPulse);
                
                // INTERACTION: Only pulse if mask is active
                pulse *= interact;
                
                // Fill mask (inner part of hex)
                float fill = 1.0 - smoothstep(inner - aa, inner + aa, dist);
                
                // Select Random Stroke Color
                // We reuse the noise/hash logic
                // Partition noise [0,1] into 3 buckets
                vec3 strokeColor = uStrokeColor1;
                if(noise > 0.33) strokeColor = uStrokeColor2;
                if(noise > 0.66) strokeColor = uStrokeColor3;
                
                // INTERACTION: Glow stroke in masked area
                strokeColor += uPulseColor * interact * 2.0;
                
                vec3 finalColor = vec3(0.0);
                
                // Add stroke
                finalColor = mix(finalColor, strokeColor, stroke);
                
                // Add pulse (mixing into fill)
                // mix existing color with pulse color based on pulse factor * fill mask
                finalColor = mix(finalColor, uPulseColor, pulse * fill);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        
        const getCanvasSize = () => ({
            w: window.innerWidth,
            h: window.innerHeight * 1.5
        });
        let canvasSize = getCanvasSize();
        
        renderer.setSize(canvasSize.w, canvasSize.h);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- PING PONG BUFFERS ---
        const simRes = 512; 
        const simParams = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType 
        };
        let simBufferA = new THREE.WebGLRenderTarget(simRes, simRes, simParams);
        let simBufferB = new THREE.WebGLRenderTarget(simRes, simRes, simParams);
        
        const simScene = new THREE.Scene();
        const simCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        const simUniforms = {
            uTexture: { value: null },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uResolutionRatio: { value: canvasSize.w / canvasSize.h },
            uCursorRadius: { value: 8.0 },
            uDecay: { value: 0.96 },
            uTime: { value: 0 }
        };
        
        const simMaterial = new THREE.ShaderMaterial({
            uniforms: simUniforms,
            vertexShader: simVertexShader,
            fragmentShader: simFragmentShader
        });
        
        const simQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), simMaterial);
        simScene.add(simQuad);

        // --- MAIN SCENE ---
        const mainUniforms = {
            uTime: { value: 0 },
            uResolution: { value: new THREE.Vector2(canvasSize.w, canvasSize.h) },
            uScale: { value: 20.0 }, // Initial tile size
            uStrokeWidth: { value: 0.02 },
            uGap: { value: 0.01 },
            // Pulse defaults
            uPulseSpeed: { value: 2.0 },
            uPulseDensity: { value: 0.2 }, 
            uPulseColor: { value: new THREE.Color(0x00ffff) }, // Cyan
            // Stroke defaults - Dark variations
            uStrokeColor1: { value: new THREE.Color(0x1a1a2e) }, // Dark Blue
            uStrokeColor2: { value: new THREE.Color(0x16213e) }, // Slightly lighter Blue
            uStrokeColor3: { value: new THREE.Color(0x0f3460) },  // Even lighter Blue
            // Mask from Sim
            uMask: { value: null } 
        };

        // --- MAP GROUP (Container for Map) ---
        const mapGroup = new THREE.Group();
        scene.add(mapGroup);

        const mapGeo = new THREE.PlaneGeometry(2, 2); // Full screen quad
        const mapMat = new THREE.ShaderMaterial({
            uniforms: mainUniforms,
            vertexShader: mapVertexShader,
            fragmentShader: mapFragmentShader
        });
        const mapPlane = new THREE.Mesh(mapGeo, mapMat);
        mapGroup.add(mapPlane);

        const canvasContainer = document.getElementById('canvas-container');

        // Mouse Tracking UPDATE
        document.addEventListener('mousemove', (e) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Normalize to 0-1, y flipped for UV
            const u = x / rect.width;
            const v = 1.0 - (y / rect.height);
            
            simUniforms.uMouse.value.set(u, v);
        });

        // Resize
        window.addEventListener('resize', () => {
             canvasSize = getCanvasSize();
             renderer.setSize(canvasSize.w, canvasSize.h);
             composer.setSize(canvasSize.w, canvasSize.h);
             
             // Update shader uniforms
             mainUniforms.uResolution.value.set(canvasSize.w, canvasSize.h);
             simUniforms.uResolutionRatio.value = canvasSize.w / canvasSize.h;
        });

        // A-Move Click Effect
        document.addEventListener('click', (e) => {
            spawnAMoveMarker(e.clientX, e.clientY + window.scrollY); // Account for scroll
        });

        function spawnAMoveMarker(x, y) {
            const marker = document.createElement('div');
            marker.className = 'amove-marker';
            marker.style.left = x + 'px';
            marker.style.top = y + 'px';
            
            for(let i=0; i<4; i++) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                if (i===0) arrow.style.setProperty('--angle', '0deg');
                if (i===1) arrow.style.setProperty('--angle', '90deg');
                if (i===2) arrow.style.setProperty('--angle', '180deg');
                if (i===3) arrow.style.setProperty('--angle', '270deg');
                marker.appendChild(arrow);
            }
            
            document.body.appendChild(marker);
            
            setTimeout(() => {
                marker.remove();
            }, 500);
        }

        // Initialize Clock
        const clock = new THREE.Clock();

        // --- POST PROCESSING USELESS FOR FIXED BG BUT GOOD FOR BLOOM ---
        const composer = new EffectComposer(renderer);
        
        const mapPass = new RenderPass(scene, camera);
        composer.addPass(mapPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            1.5,   // Strength
            0.1,  // Radius
            0.3    // Threshold
        );
        composer.addPass(bloomPass);

        // --- DEBUG GUI ---
        const gui = new GUI({ title: 'A-Move Debug' });

        const settings = {
            // Scroll tracking
            scrollY: 0,
            scrollPercent: 0,
            // Hex Pattern Defaults
            scale: 20.0,
            strokeWidth: 0.02,
            gap: 0.01,
            // Pulse Defaults
            pulseSpeed: 2.0,
            pulseDensity: 0.05,
            pulseColor: { r: 0, g: 1, b: 1 }, 
            // Stroke Defaults
            strokeColor1: { r: 0.1, g: 0.1, b: 0.18 }, // #1a1a2e
            strokeColor2: { r: 0.08, g: 0.13, b: 0.24 }, // #16213e
            strokeColor3: { r: 0.06, g: 0.2, b: 0.37 }, // #0f3460
            
            // Interaction
            cursorRadius: 8.0,
            decay: 0.96, // Decay
            
            export: function() {
                const config = {
                    typography: {
                        scanThickness: settings.scanThickness,
                        scanGap: settings.scanGap,
                        titleGlow: settings.titleGlow
                    },
                    hexPattern: {
                        scale: settings.scale,
                        strokeWidth: settings.strokeWidth,
                        gap: settings.gap
                    },
                    pulse: {
                        speed: settings.pulseSpeed,
                        density: settings.pulseDensity,
                        color: settings.pulseColor
                    },
                    strokeColors: {
                        c1: settings.strokeColor1,
                        c2: settings.strokeColor2,
                        c3: settings.strokeColor3
                    },
                    interaction: {
                        radius: settings.cursorRadius,
                        decay: settings.decay
                    }
                };
                const json = JSON.stringify(config, null, 2);
                console.log("--- SAVED CONFIG ---");
                console.log(json);
                alert("Settings exported to Console (F12)!");
            },
            // Typography State
            scanThickness: 6.66,
            scanGap: 0,
            titleGlow: 13.6,
            devsGlow: 4
        };

        // Sync Helper
        function updateCSS(varName, value, unit='px') {
            document.documentElement.style.setProperty(varName, value + unit);
        }


        const fTypo = gui.addFolder('Typography');
        fTypo.add(settings, 'scanThickness', 1, 10).name('Scan Thickness').onChange(v => updateCSS('--scan-thickness', v));
        fTypo.add(settings, 'scanGap', 0, 10).name('Scan Gap').onChange(v => updateCSS('--scan-gap', v));
        fTypo.add(settings, 'titleGlow', 0, 50).name('Title Glow').onChange(v => updateCSS('--title-glow', v));
        fTypo.add(settings, 'devsGlow', 0, 100).name('Devs Glow').onChange(v => {
            updateCSS('--devs-glow-1', v);
            updateCSS('--devs-glow-2', v * 2);
            updateCSS('--devs-glow-3', v * 3);
        });
        
        const fHex = gui.addFolder('Hex Background');
        fHex.add(settings, 'scale', 5.0, 100.0).name('Tile Scale').onChange(v => mainUniforms.uScale.value = v);
        fHex.add(settings, 'strokeWidth', 0.001, 0.2).name('Stroke Width').onChange(v => mainUniforms.uStrokeWidth.value = v);
        fHex.add(settings, 'gap', 0.0, 0.2).name('Tile Gap').onChange(v => mainUniforms.uGap.value = v);
        
        const fStroke = fHex.addFolder('Stroke Colors');
        fStroke.addColor(settings, 'strokeColor1').name('Color 1').onChange(v => mainUniforms.uStrokeColor1.value.setRGB(v.r, v.g, v.b));
        fStroke.addColor(settings, 'strokeColor2').name('Color 2').onChange(v => mainUniforms.uStrokeColor2.value.setRGB(v.r, v.g, v.b));
        fStroke.addColor(settings, 'strokeColor3').name('Color 3').onChange(v => mainUniforms.uStrokeColor3.value.setRGB(v.r, v.g, v.b));
        
        const fPulse = fHex.addFolder('Pulse Effect');
        fPulse.add(settings, 'pulseSpeed', 0.0, 10.0).name('Speed').onChange(v => mainUniforms.uPulseSpeed.value = v);
        fPulse.add(settings, 'pulseDensity', 0.0, 0.5).name('Density').onChange(v => mainUniforms.uPulseDensity.value = v);
        fPulse.addColor(settings, 'pulseColor').name('Color').onChange(v => {
            mainUniforms.uPulseColor.value.setRGB(v.r, v.g, v.b);
        });
        
        const fInteract = fHex.addFolder('Interaction');
        fInteract.add(settings, 'cursorRadius', 1.0, 20.0).name('Radius').onChange(v => simUniforms.uCursorRadius.value = v);
        fInteract.add(settings, 'decay', 0.8, 0.999).name('Trail Persistence').onChange(v => simUniforms.uDecay.value = v);
        
        fHex.open();
        
        const fBloom = gui.addFolder('Bloom');
        fBloom.add(bloomPass, 'strength', 0.0, 5.0).name('Strength');
        fBloom.add(bloomPass, 'radius', 0.0, 1.0).name('Radius');
        fBloom.add(bloomPass, 'threshold', 0.0, 1.0).name('Threshold');
        
        const fScroll = gui.addFolder('Scroll Info');
        const scrollYController = fScroll.add(settings, 'scrollY').name('Scroll Y (px)').listen().disable();
        const scrollPercentController = fScroll.add(settings, 'scrollPercent').name('Scroll %').listen().disable();
        // fScroll.open();

        gui.add(settings, 'export').name('ðŸ’¾ EXPORT SETTINGS');

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            mainUniforms.uTime.value = clock.getElapsedTime();
            
            // --- STEP 1: RENDER SIMULATION ---
            // Sim Buffer Swap
            const bufferRead = simBufferA;
            const bufferWrite = simBufferB;
            
            simUniforms.uTexture.value = bufferRead.texture;
            
            renderer.setRenderTarget(bufferWrite);
            renderer.render(simScene, simCamera);
            
            // Pass the new texture to the main shader
            mainUniforms.uMask.value = bufferWrite.texture;
            
            // Swap Buffers for next frame
            simBufferA = bufferWrite;
            simBufferB = bufferRead;
            
            // --- STEP 2: RENDER MAIN SCENE ---
            renderer.setRenderTarget(null); // Screen
            
            // Parallax
            const scrollY = window.scrollY;
            const parallaxOffset = scrollY * -0.3; 
            canvasContainer.style.transform = `translateY(${parallaxOffset}px)`;
            
            settings.scrollY = Math.round(scrollY);

            composer.render();
        }
        animate();
    </script>
</body>
</html>
